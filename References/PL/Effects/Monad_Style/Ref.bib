@article{article,
author = {McBride, Conor and Paterson, Ross},
year = {2008},
month = {01},
pages = {1-13},
title = {Applicative Programming with Effects},
volume = {18},
journal = {Journal of Functional Programming},
doi = {10.1017/S0956796807006326}
}

@article{10.1145/601775.601776,
author = {Wadler, Philip and Thiemann, Peter},
title = {The marriage of effects and monads},
year = {2003},
issue_date = {January 2003},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {1},
issn = {1529-3785},
url = {https://doi.org/10.1145/601775.601776},
doi = {10.1145/601775.601776},
abstract = {Gifford and others proposed an effect typing discipline to delimit the scope of computational effects within a program, while Moggi and others proposed monads for much the same purpose. Here we marry effects to monads, uniting two previously separate lines of research. In particular, we show that the type, region, and effect system of Talpin and Jouvelot carries over directly to an analogous system for monads, including a type and effect reconstruction algorithm. The same technique should allow one to transpose any effect system into a corresponding monad system.},
journal = {ACM Trans. Comput. Logic},
month = {jan},
pages = {1–32},
numpages = {32},
keywords = {type reconstruction, type, region, effect, Monad}
}

@inproceedings{10.1145/2633357.2633368,
author = {Orchard, Dominic and Petricek, Tomas},
title = {Embedding effect systems in Haskell},
year = {2014},
isbn = {9781450330411},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2633357.2633368},
doi = {10.1145/2633357.2633368},
abstract = {Monads are now an everyday tool in functional programming for abstracting and delimiting effects. The link between monads and effect systems is well-known, but in their typical use, monads provide a much more coarse-grained view of effects. Effect systems capture fine-grained information about the effects, but monads provide only a binary view: effectful or pure.Recent theoretical work has unified fine-grained effect systems with monads using a monad-like structure indexed by a monoid of effect annotations (called parametric effect monads). This aligns the power of monads with the power of effect systems.This paper leverages recent advances in Haskell's type system (as provided by GHC) to embed this approach in Haskell, providing user-programmable effect systems. We explore a number of practical examples that make Haskell even better and safer for effectful programming. Along the way, we relate the examples to other concepts, such as Haskell's implicit parameters and coeffects.},
booktitle = {Proceedings of the 2014 ACM SIGPLAN Symposium on Haskell},
pages = {13–24},
numpages = {12},
keywords = {type systems, parametric effect monads, effect systems},
location = {Gothenburg, Sweden},
series = {Haskell '14}
}

@article{10.1145/2775050.2633368,
author = {Orchard, Dominic and Petricek, Tomas},
title = {Embedding effect systems in Haskell},
year = {2014},
issue_date = {December 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/2775050.2633368},
doi = {10.1145/2775050.2633368},
abstract = {Monads are now an everyday tool in functional programming for abstracting and delimiting effects. The link between monads and effect systems is well-known, but in their typical use, monads provide a much more coarse-grained view of effects. Effect systems capture fine-grained information about the effects, but monads provide only a binary view: effectful or pure.Recent theoretical work has unified fine-grained effect systems with monads using a monad-like structure indexed by a monoid of effect annotations (called parametric effect monads). This aligns the power of monads with the power of effect systems.This paper leverages recent advances in Haskell's type system (as provided by GHC) to embed this approach in Haskell, providing user-programmable effect systems. We explore a number of practical examples that make Haskell even better and safer for effectful programming. Along the way, we relate the examples to other concepts, such as Haskell's implicit parameters and coeffects.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {13–24},
numpages = {12},
keywords = {type systems, parametric effect monads, effect systems}
}

@article{10.1145/3547640,
author = {Ullrich, Sebastian and de Moura, Leonardo},
title = {‘do’ unchained: embracing local imperativity in a purely functional language (functional pearl)},
year = {2022},
issue_date = {August 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {ICFP},
url = {https://doi.org/10.1145/3547640},
doi = {10.1145/3547640},
abstract = {Purely functional programming languages pride themselves with reifying effects that are implicit in imperative languages into reusable and composable abstractions such as monads. This reification allows for more exact control over effects as well as the introduction of new or derived effects. However, despite libraries of more and more powerful abstractions over effectful operations being developed, syntactically the common 'do' notation still lags behind equivalent imperative code it is supposed to mimic regarding verbosity and code duplication. In this paper, we explore extending 'do' notation with other imperative language features that can be added to simplify monadic code: local mutation, early return, and iteration. We present formal translation rules that compile these features back down to purely functional code, show that the generated code can still be reasoned over using an implementation of the translation in the Lean 4 theorem prover, and formally prove the correctness of the translation rules relative to a simple static and dynamic semantics in Lean.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {109},
numpages = {28},
keywords = {interactive theorem proving, functional programming, Lean}
}