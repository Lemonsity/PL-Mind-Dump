@article{10.1145/3674655,
author = {Xue, Xu and Oliveira, Bruno C. d. S.},
title = {Contextual Typing},
year = {2024},
issue_date = {August 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {ICFP},
url = {https://doi.org/10.1145/3674655},
doi = {10.1145/3674655},
abstract = {Bidirectional typing is a simple, lightweight approach to type                                inference that propagates known type information during typing,                                and can scale up to many different type systems and features.                                It typically only requires a reasonable amount of                                annotations and eliminates the need for many obvious                                annotations. Nonetheless the power of inference is still                                 limited, and complications arise in the presence of more                                complex features.                                                                 In this paper we present a generalization of bidirectional typing                                called contextual typing. In contextual typing not only known                                type information is propagated during typing, but also other known information                                about the surrounding context of a term. This information can                                be of various forms, such as other terms or record labels.                                Due to this richer notion of contextual                                information, less annotations are needed, while the approach                                remains lightweight and                                scalable. For type systems with subtyping, contextual                                typing subsumption is also more expressive than subsumption with                                bidirectional typing, since partially known                                contextual information can be exploited.                                To aid                                specifying type systems with contextual typing, we introduce                                Quantitative Type Assignment Systems                                (QTASs). A QTAS quantifies the amount of type information that a                                term needs in order to type check using counters. Thus, a counter in                                a QTAS generalizes modes in traditional bidirectional typing, which can                                only model an                                all (checking mode) or nothing (inference mode) approach.                                QTASs enable precise guidelines for annotatability of contextual type systems                                formalized as a theorem.                                We illustrate contextual typing first on a simply typed lambda                                calculus, and then on a richer calculus with subtyping, intersection                                types, records and overloading. All the metatheory is formalized in                                the Agda theorem prover.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {266},
numpages = {29},
keywords = {Bidirectional Typing, Type Inference}
}

@article{10.1145/3674634,
author = {Chen, Yijia and Parreaux, Lionel},
title = {The Long Way to Deforestation: A Type Inference and Elaboration Technique for Removing Intermediate Data Structures},
year = {2024},
issue_date = {August 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {ICFP},
url = {https://doi.org/10.1145/3674634},
doi = {10.1145/3674634},
abstract = {Deforestation is a compiler optimization that removes intermediate data structure allocations from functional programs to improve their efficiency. This is an old idea, but previous approaches have proved limited or impractical â€” they either only worked on compositions of predefined combinators (shortcut fusion), or involved the aggressive unfolding of recursive definitions until a depth limit was reached or a reoccurring pattern was found to tie the recursive knot, resulting in impractical algorithmic complexity and large amounts of code duplication. We present Lumberhack, a general-purpose deforestation approach for purely functional call-by-value programs. Lumberhack uses subtype inference to reason about data structure production and consumption and uses an elaboration pass to fuse the corresponding recursive definitions. It fuses large classes of mutually recursive definitions while avoiding much of the unproductive (and sometimes counter-productive) code duplication inherent in previous approaches. We prove the soundness of Lumberhack using logical relations and experimentally demonstrate significant speedups in the standard nofib benchmark suite. We manually adapted nofib programs to call-by-value semantics and compiled them using the OCaml compiler. The average speedup over the 38 benchmarked programs is 8.2\% while the average code size increases by just about 1.79x. In particular, 19 programs see their performance mostly unchanged, 17 programs improve significantly (by an average speedup of 16.6\%), and only three programs visibly worsen (by an average slowdown of 1.8\%). As a point of comparison, we measured that the well-proven but semi-manual list fusion technique of the Glasgow Haskell Compiler (GHC), which only works for call-by-need programs, had an average speedup of 6.5\%. Our technique is in its infancy still and misses many deforestation opportunities. We are confident that further refinements to the core technique will yield greater performance improvements in the future.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {245},
numpages = {35},
keywords = {deforestation, elaboration, elaboration, fusion, fusion, optimization, optimizationdeforestation, type inference, type inference}
}